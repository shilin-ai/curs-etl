# Qdrant: Унифицированная схема чанка (v1)

**Назначение.** Эта спецификация описывает единый формат хранения фрагментов знаний (чанков) из разных источников (Confluence, YouTrack, GitLab, Yandex Disk, Miro, n8n, web‑сайты и т.д.) в одной коллекции Qdrant. Цель — обеспечить консистентное индексирование, быстрый поиск (векторный + фильтры по метаданным) и лёгкую масштабируемость при добавлении новых источников.

---

## 1) Коллекция

- Рекомендуемая коллекция: `knowledge_chunks` (одна общая коллекция).
- Расстояние для эмбеддингов: `Cosine` (подходит для нормализованных текстовых эмбеддингов).
- Размер вектора (`vector_size`): соответствует используемой модели эмбеддингов (например, 1024). Значение фиксируется в настройках коллекции.
- Рекомендуемые параметры HNSW (для больших объёмов):
  - `m = 16–32`, `ef_construct = 200–400`.
  - Поиск: `ef_search = 64–256` (подбирается эмпирически).
- Квантование (по необходимости): scalar/int8 для экономии памяти при больших объёмах; валидируйте, что качество поиска приемлемо.

Создавайте payload‑индексы в Qdrant для часто используемых фильтров (см. §6):
- `source` — keyword
- `type` — keyword
- По мере необходимости: `author`, `id_in_source`, `updated_at`, `created_at` и др.

---

## 2) Модель данных (JSON‑структура)

**Топ‑уровень (точка Qdrant):**
```json
{
  "id": "uuid",              
  "vector": [ ... ],          
  "payload": { ... }
}
```

**Поле `payload` (детализация):**
```json
{
  "source": "gitlab | confluence | youtrack | yandex_disk | miro | n8n | website | ...",
  "type":   "file | commit | page | ticket | doc | board | workflow | site_page | video | ...",

  "id_in_source": "string",
  "title":        "string | null",
  "url":          "string | null",
  "text":         "string",
  "chunk_index":  0,
  "chunk_count":  1,

  "created_at":   "ISO8601 | null",
  "updated_at":   "ISO8601 | null",
  "author":       "string | null",

  "metadata":     { }
}
```

### 2.1 Обязательность полей
- **Обязательные:**
  - `payload.source`
  - `payload.type`
  - `payload.text`
  - `payload.chunk_index`
  - `payload.chunk_count`
- **Желательно (при наличии):**
  - `id` (если не задан — генерируется UUID на стороне инжестера)
  - `payload.id_in_source`
  - `payload.updated_at`
  - `payload.title`, `payload.url`
  - `payload.created_at`, `payload.author`
- **Опционально/расширяемо:**
  - `payload.metadata` — свободная структура для полей, специфичных для источника.

### 2.2 Ограничения и инварианты
- `id` — глобально уникален в коллекции (UUID v4/v5). Рекомендуется **детерминированный UUID v5** на основе `source + id_in_source + chunk_index` для идемпотентных апдейтов.
- `(id_in_source, chunk_index)` — уникальная пара внутри одного `source` (и, если применимо, внутри одной «сущности»: репозиторий/страница/тикет). Это облегчает обновления без дубликатов.
- `chunk_index ∈ [0 .. chunk_count-1]`.
- Временные поля (`created_at`, `updated_at`) в формате ISO‑8601 (UTC), например: `2025-08-28T14:03:27Z`.
- `text` — уже нормализованный для поиска контент (см. §3), без бинарных данных.

---

## 3) Нормализация текста
- Текст должен быть подготовлен для эмбеддинга и полнотекстового показа в ответах:
  - Удаление управляющих символов, декодирование HTML/Markdown при необходимости.
  - Сохранение **структурной полезной информации** (заголовки, списки, кодовые блоки) — без агрессивной «плоскости».
  - Единая кодировка: UTF‑8.
- Для кода (GitLab файлы): сохраняйте отрывки кода как есть; добавляйте путь файла в `title` или `metadata.path`.
- Для видео: `text` = транскрипт соответствующего фрагмента; в `metadata` можно хранить таймкоды и ссылки на спикера/сцену.

---

## 4) Чанкование
- Базовое правило: деление исходного документа/объекта на части, удобные для высококачественных эмбеддингов и ответа модели.
- Рекомендуемые параметры (ориентиры):
  - Длина чанка: **800–1200** символов (или ~200–400 токенов).
  - Перекрытие: **10–20%** по символам/токенам для сохранения контекста.
- Для коротких сущностей (коммиты, тикеты) возможно `chunk_count = 1`.
- Для длинных документов учитывайте **логические границы** (заголовки, абзацы, секции, функции в коде).

---

## 5) Эмбеддинги
- Вектор (`vector`) — результат эмбеддинга `payload.text`.
- Используйте **одну и ту же модель** эмбеддингов для всех источников внутри коллекции (или заведите разные коллекции под разные модели/размеры вектора).
- Нормализуйте векторы (L2) для использования `Cosine`.
- Генерация **батчами** (например, 64–256 элементов) с троттлингом под лимиты провайдера.

---

## 6) Индексация и фильтрация
Создавайте payload‑индексы (Qdrant Payload Index) на часто используемые ключи, чтобы ускорить фильтрацию:
- `source` (e.g. `gitlab`, `confluence`, `youtrack`, `website`, ...)
- `type` (e.g. `file`, `commit`, `page`, `ticket`, `doc`, ...)
- Дополнительно по потребности: `author`, `id_in_source`, `created_at`, `updated_at`, домен сайта, проект и т.п. — обычно в `metadata`.

**Примеры фильтров:**
- Только коммиты GitLab: `source = gitlab AND type = commit`.
- Только страницы Confluence за последние N дней: `source = confluence AND type = page AND updated_at >= ...`.
- Тикеты YouTrack конкретного проекта: `source = youtrack AND metadata.project = MYAPP`.

---

## 7) Операции записи/обновления (ingestion)
- **Idempotent upsert.** Используйте детерминированный `id` (UUID v5 по `source/id_in_source/chunk_index`). Повторные заливки не создадут дубликатов.
- **Пакетная запись**: upsert батчами (например, по 500–1000 точек), логируйте прогресс.
- **Дедупликация**: при изменениях содержимого (diff) регенерируйте только затронутые чанки; неизменные чанки не трогайте.
- **Обновления метаданных** (title/url/author/updated_at) допускаются без пересоздания вектора, если `text` не менялся.
- **Удаление**: мягкое (soft‑delete) через флаг в `metadata.deleted = true` (для истории) либо жёсткое удаление точки из коллекции (экономия места).

---

## 8) Запросы (паттерны)

### 8.1 Поиск по всем источникам
- Векторный поиск по `query_vector` + ограничение `limit`.
- (Опционально) фильтры по времени `updated_at` для свежих ответов.

### 8.2 Поиск только по GitLab коммитам
- Фильтр: `source = gitlab`, `type = commit`.

### 8.3 Поиск по документам Confluence
- Фильтр: `source = confluence`, `type = page`.

### 8.4 Поиск по сайтам определённого домена
- Фильтр: `source = website`, `metadata.domain = example.com`.

### 8.5 Сборка полного документа из чанков
- Найдя релевантные чанки одного `id_in_source`, получите все чанки этой сущности фильтром по `id_in_source` и отсортируйте по `chunk_index`.

---

## 9) Версионирование схемы
- В рамках `v1` набор полей фиксирован (как в этой спецификации).
- Добавление новых источников/типов не требует изменения схемы — используйте новые значения `source`/`type` и расширяйте `metadata`.
- При будущих несовместимых изменениях создавайте новую коллекцию (например, `knowledge_chunks_v2`) либо добавьте в `metadata.schema_version = 2` и поддерживайте миграцию.

---

## 10) Безопасность и приватность
- Не индексируйте чувствительные данные без необходимости. Возможные подходы:
  - Маскирование PII до эмбеддинга.
  - Исключение приватных полей из `text`, хранение их только в `metadata` (и не показывать пользователю).
- Контролируйте доступ на уровне приложения: Qdrant не реализует сложные ACL; ограничивайте видимость на шаге выборки.

---

## 11) Наблюдаемость и качество
- Логируйте пайплайн инжеста: источник, кол-во сущностей, кол-во чанков, % обновлений, ошибки.
- Метрики качества поиска: CTR кликов по результатам, ручные метки релевантности, доля пустых ответов.
- Тестируйте на «золотых» наборах запросов по каждому источнику.

---

## 12) Примеры

### 12.1 Пример точки для GitLab файла
```json
{
  "id": "8b5a3b3a-8f2a-5e17-9a0a-6b9e3b2b9c0f",
  "vector": [ ... ],
  "payload": {
    "source": "gitlab",
    "type": "file",
    "id_in_source": "repo:etl-bot|path:src/utils/qdrantutils.py|ref:main",
    "title": "src/utils/qdrantutils.py",
    "url": "https://gitlab.example.com/etl-bot/-/blob/main/src/utils/qdrantutils.py",
    "text": "def upsert_chunks(...)",
    "chunk_index": 0,
    "chunk_count": 3,
    "created_at": null,
    "updated_at": "2025-08-28T09:15:00Z",
    "author": "alex",
    "metadata": {
      "repo": "etl-bot",
      "branch": "main",
      "path": "src/utils/qdrantutils.py"
    }
  }
}
```

### 12.2 Пример точки для YouTrack тикета
```json
{
  "id": "5c2f1e7a-5a09-592f-8e3f-2b0a5c9a1d42",
  "vector": [ ... ],
  "payload": {
    "source": "youtrack",
    "type": "ticket",
    "id_in_source": "YT-1234",
    "title": "ETL pipeline fails on missing env",
    "url": "https://youtrack.example.com/issue/YT-1234",
    "text": "Steps to reproduce: ...",
    "chunk_index": 0,
    "chunk_count": 1,
    "created_at": "2025-08-25T12:00:00Z",
    "updated_at": "2025-08-27T10:30:00Z",
    "author": "ivan",
    "metadata": {
      "project": "MYAPP",
      "status": "Open"
    }
  }
}
```

### 12.3 Пример точки для страницы Confluence
```json
{
  "id": "c349f2a3-6f7e-5f11-8d31-2b3d6c4e1a9b",
  "vector": [ ... ],
  "payload": {
    "source": "confluence",
    "type": "page",
    "id_in_source": "SPACE-123",
    "title": "Qdrant: best practices",
    "url": "https://wiki.example.com/pages/viewpage.action?pageId=123",
    "text": "Qdrant is a vector database ...",
    "chunk_index": 1,
    "chunk_count": 4,
    "created_at": "2025-07-10T08:00:00Z",
    "updated_at": "2025-08-20T17:40:00Z",
    "author": "kate",
    "metadata": {
      "space": "ENG",
      "labels": ["architecture"]
    }
  }
}
```

### 12.4 Пример точки для фрагмента видео (Yandex Disk / YouTube)
```json
{
  "id": "9f2c7e11-4b91-5a2c-8c77-6a1b7d4c3e20",
  "vector": [ ... ],
  "payload": {
    "source": "yandex_disk",
    "type": "video",
    "id_in_source": "yd:/videos/meetup.mp4#t=750-900",
    "title": "Meetup: ETL updates (excerpt)",
    "url": null,
    "text": "(транскрипт фрагмента 12:30–15:00)",
    "chunk_index": 2,
    "chunk_count": 6,
    "created_at": null,
    "updated_at": "2025-08-22T11:00:00Z",
    "author": null,
    "metadata": {
      "timestamp_start": "00:12:30",
      "timestamp_end": "00:15:00",
      "video_path": "/videos/meetup.mp4"
    }
  }
}
```

---

## 13) Рекомендации по реализации
- **ID‑схема:** `uuid5(namespace, f"{source}|{id_in_source}|{chunk_index}")` — детерминированно и устойчиво к повторным инжестам.
- **Batch‑ingestion:** используйте усреднённые батчи (500–1000) и backoff при ошибках/квотах.
- **Ретрай политика:** экспоненциальный backoff, дедуп по `id` перед повторной попыткой.
- **Тесты:** фикстуры на каждый источник; снэпшоты JSON‑структур; контроль формата ISO‑дат.
- **Observability:** метрики инжеста (в штуках и байтах), время эмбеддинга, RPS к Qdrant, насыщение индекса.

---

## 14) Ограничения и будущие улучшения
- Отсутствуют «связи» между сущностями (issue ↔ commit ↔ страница). Если нужны графовые связи — хранить отдельно (Postgres/Neo4j) и сшивать на уровне приложения.
- Возможность мультимодальных векторов (аудио/видео/изображения) — допустима при едином `vector_size`; иначе выносить в отдельные коллекции по модальности/модели.
- Рассмотреть добавление доп. служебных полей в `metadata` (например, `schema_version`, `ingested_at`, `deleted`). В рамках этой версии спецификации они не обязательны.

---

**Статус документа:** v1 (стабильная минимально достаточная схема).

